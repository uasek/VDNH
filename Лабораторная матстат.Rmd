---
title: "Идеи для лабораторной по матстату"
author: "Михаил Баранов"
output: 
  html_document: 
    highlight: pygments
---

```{r}
library(ggplot2)
library(emo) #emoji
library(knitr) #для мема и таблички в 3 задаче
set.seed(3141593) #для воспроизведения результатов
```

# Задача 1. Метод Монте-Карло и вычисление $\pi$

Одно из основных преимуществ, которое дает среда R (или любая другая) при изучении теории вероятностей и математической статистики - это возможность буквально "почуствовать" предмет изучения при помощи генерации *псевдо*случайных величин.

Приставка "псевдо" тут стоит не просто так: алгоритмы R, генерирующие эти числа, абсолютно детерминированные, однако статистические свойства получаемых чисел неотличимы от "настоящих" случайных величин. Оставим этот почти философский вопрос и двинемся дальше`r ji('wink')`.

Итак, пусть мы выбираем наудачу точку из квадрата со стороной $2$. Случайная величина $X$ равна единице, если эта точка лежит внутри круга, вписанного в этот квадрат, и нулю в противном случае:

```{r, echo = FALSE}
x = c(-1, -1, 1, 1)
y = c(-1, 1, 1, -1)
z <- seq(0, 2 * pi, length.out = 100)
```

```{r, echo = FALSE}
ggplot() + 
  geom_polygon(aes(x, y), fill = NA, color = 'black') + 
  coord_fixed() + theme_classic() + 
  geom_vline(xintercept = 0, linetype = 'dashed') + 
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_path(aes(cos(z), sin(z)), color = 'royalblue') +
  geom_point(aes(c(-0.314, 0.8), c(-0.271, 0.7)), color = c('seagreen', 'red')) + 
  geom_text(aes(-0.314, -0.2, label = 'X = 1'), size = 5, color = 'seagreen') +
  geom_text(aes(0.8, 0.77, label = 'X = 0'), size = 5, color = 'red')
```

Нетрудно видеть, что $$\mathbb{P}(X=1)=\frac{площадь\;круга}{площадь\; квадрата}=\frac{\pi}{4}$$

Если же мы выберем достаточно много точек из квадрата, то доля попавших в круг точек будет некоторым приближением (оценкой) искомой вероятности!

```{r, echo = FALSE}
X <- runif(1e3, -1, 1)
Y <- runif(1e3, -1, 1)
in_circle <- (X ^ 2 + Y ^ 2) < 1
```

```{r, echo = FALSE}
ggplot() + 
  geom_polygon(aes(x, y), fill = NA, color = 'black') + 
  coord_fixed() + theme_classic() + 
  geom_vline(xintercept = 0, linetype = 'dashed') + 
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_path(aes(cos(z), sin(z)), color = 'royalblue') +
  geom_point(aes(X[in_circle], Y[in_circle]), color = 'seagreen') +
  geom_point(aes(X[!in_circle], Y[!in_circle]), color = 'red')
```

Для начала сгенерируем реализацию $10000$ (псевдо)случайных равномерно распредленных на отрезке $[-1, 1]$ величин для x-координаты и для y-координаты.

```{r}
X <- runif(n = 1e4, min = -1, max = 1)
Y <- runif(1e4, -1, 1)
```

Для этого мы воспользовались функцией `runif`, генерирующей выборку из равномерного распределения. В документации к ней можно найти, как вычислять функцию плотности, распределения, а также квантили. Документацию к любой функции можно вызвать в консоли при помощи вопросительного знака перед ее названием: `?runif`

И вообще:

```{r, out.width = "400px", echo = FALSE}
knitr::include_graphics('meme.png')
```

Читайте документацию!

Точка лежит в круге, если сумма квадратов ее координат меньше единицы. Но как нам это быстро посчитать для 10000 точек? Воспользуемся тем же принципом, который лежит в основе следующей строчки кода:

```{r}
c(1, 2, 3, 4, 5) > 3
```

Операция сравнения была проведена для *каждого элемента* вектора, и на выходе мы получили вектор такой же длины. 

Аналогично операции над векторами одинаковой длины, будут производиться для каждой *пары* элементов, имеющих одинаковый индекс (пары первых элементов, пары вторых и т.д.)

```{r}
a <- c(1, 2, 3, 4)
b <- c(2, 2, 2, 2)
b ^ a
```

Таким образом, мы можем быстро посчитать, какие точки находятся в круге, сначала найдя расстояние от центра окружности, а затем сравнив его с единицей:

```{r}
distance <- X ^ 2 + Y ^ 2
distance[1:5]
```

```{r}
in_circle <- distance < 1
in_circle[1:5]
```

Значение `TRUE` говорит нам о том, что случайная точка оказалась внутри окружности. Доля таких точек - оценка искомой вероятности, а именно $\frac{\pi}{4}$

```{r}
mean(in_circle)
```

Расчитаем на основе этой вероятности оценку для $\pi$

```{r}
4 * mean(in_circle)
```

```{r}
pi
```

Описанная выше процедура называется **метод Монте-Карло**: приближенное вычисление вероятности при помощи многократной генерации случайных величин. 

В одномерном случае он не так полезен из-за высокой погрешности. Чтобы в этом убедиться, можете попробовать приблизить $\pi$ при помощи выборки размера $10^6$ или даже $10^7$. Получится ли получить хотя бы три верных знака после запятой?

Однако в многомерном случае Монте-Карло - зачастую единственный выход, поскольку вычислительная сложность обычных алгоритмов нахождения объемов тел растет экспоненциально с увеличением размерности задачи.

## Задание.

Посчитайте методом Монте-Карло приближенное значение $\ln(2)$. Используйте $10000$ случайных точкек, выбранных из квардрата с вершинами $(1, 0),\;(1, 1),\; (2, 0),\; (2, 1)$. Попадание под график какой функции необходимо использовать? 

# Задача 2. Метод обратной функции.

Продолжим работу с равномерно распределенными случайными величинами. Оказывается, что с их помощью можно получать случайные величины с произвольной плотностью. Сразу обратимся к примеру.

Пусть $Y \sim U([0, 1])$. Какое распределение будет иметь $-\ln(Y)$? 

Для начала заметим, что (в силу симметрии) $1 - Y$ имеет такое же распределение, как и $Y$. Будем искать распределение $-\ln(1-Y)$. 

Остается лишь вывести, что $$\mathbb{P}(-\ln(1-Y) < x) = \mathbb{P}(Y < 1 - e^{-x})$$

Справа получаем функцию распределения $Y$ в точке $1 - e ^ {-x}$. Т.к. $F(x) = x$, $$F(1 - e^{-x}) = 1 - e^{-x}$$

Иными словами, $-\ln(1-Y)$, а значит и $-\ln(Y)$, имеет экспоненциальное распределение!

Убедимся в этом при помощи симуляции:

```{r}
y <- runif(1e4, 0, 1)
log_y <- -log(y)
```

Построим гистограмму и плотность экспоненциального распределения поверх нее:

```{r}
t <- seq(0, 10, length.out = 100) #точки, в которых будем считать плотность
```

```{r}
ggplot() + theme_classic() +
  
  geom_histogram(mapping = aes(x = log_y, y = ..density..), #чтобы площадь под гистограммой суммировалась в единицу
                          bins = 50, color = 'black', fill = 'seagreen') + 
  
  geom_line(mapping = aes(x = t, y = dexp(t, rate = 1)), 
            color = 'red', size = 1.1, alpha = 0.6)
```

Итак, гистограмма отлично подходит под плотность, что и требовалось доказать.

В общем случае, если у нас есть случайная величина $U$ с функцией распределения $F(x)$, то достаточно приравнять $Y = F(x)$ и выразить $x = F^{-1}(Y)$. Тогда полученное справа выражение - функция от $Y$ - будет иметь распределение такое же, как и $U$. 

Проблемы могут возникнуть лишь в точках, в которых $F^{-1}(x)$ не определена однозначно (например, в случае дискретных случайных величин). Тогда потребуется дополнительно определить, какое значение будет принимать новая случайная величина в каждой из таких точек.

## Задание.

Создайте *нормальную* выборку при помощи равномерно распределенных случайных величин. Как посчитать функцию, обратную функции распределения (**quantile function**)? Ответ поможет найти чтение документации к функции `dexp()` из графика выше `r ji('yum')`

Для полученной выборки постройте аналогичную гистограмму с графиком плотности.

# Задача 3. Распределение редких событий.

Ниже представлены данные о бомбардировках области южного Лондона во время Второй мировой войны *(источник: R.D. Clarke. An application of the Poisson distribution. Journal of
the Institute of Actuaries, 72:48, 1946; Table 1 on page 481. Faculty and Institute of Actuaries.)*. Эта область была разделена на $576$ квадратов со стороной $250$ метров, и для каждого квадрата было подсчитано число попавших туда бомб.

```{r}
number_of_hits <- 0:7
number_of_squares <- c(229, 211, 93, 35, 7, 0, 0, 1)
```

Были ли бомбардировки *абсолютно случайны*? Признаком этого может служить тот факт, что число бомб в отдельном квадрате подчиняется распределению Пуассона.

Чтобы получить первоначальное представление о том, насколько верно наше предположение, проведем симуляцию: выберем $537$ равномерно распределенных точек из квадрата $24 \times 24$ и для каждого внутреннего квадрата $1 \times 1$ посчитаем число попавших туда бомб:

```{r}
n = 24
point_x <- runif(537, 0, n)
point_y <- runif(537, 0, n)
```

Обратите внимание, как много квадратов, где вообще нет ни одной точки и где всего одна точка:

```{r, echo = FALSE}
#число попаданий в каждый квадрат (для покраски)
index <- n * floor(point_y) + floor(point_x)
index_for_table <- c(index, 0:(n ^ 2 - 1)) #чтобы выловить нули, снизу вычитаем 1 из всего
number_of_hits_sim <- tabulate(index_for_table + 1) - 1 #+ 1 потому что нужны positive integers

#вершины квадратов
x <- c()
y <- c()

for (index in 0:(n ^ 2 - 1)) {
  x0 <- index %% n
  y0 <- index %/% n
  x = c(x, x0, x0, x0 + 1, x0 + 1)
  y = c(y, y0, y0 + 1, y0 + 1, y0)
}

d <- data.frame(x = x, y = y, 
                group = rep(0:(n ^ 2 - 1), each = 4), 
                fill = rep(as.character(number_of_hits_sim), each = 4))
```

```{r, echo = FALSE}
ggplot() + 
  
  geom_polygon(data = d, aes(x, y, group = group, fill = fill), 
               color = 'black', size = 0.3) + 
  
  scale_fill_brewer(palette = 'Set2') +
  
  geom_point(aes(point_x, point_y), alpha = 0.5) + 
  
  coord_fixed() + theme_void() +
  
  labs(fill = 'Число бобм\nв квадрате')
```

Для симулированных данных оценим параметр распределения Пуассона и найдем с помощью него теоретические частоты:

```{r, echo = FALSE}
freq_sim <- tabulate(c(0:7, number_of_hits_sim) + 1) - 1 #опять ловим нули и делаем поправку из-за positive integers
freq_sim <- freq_sim / sum(freq_sim)
l_hat <- mean(number_of_hits_sim)
freq_pois <- dpois(number_of_hits, l_hat)
```

```{r, results = 'asis', echo = FALSE}
knitr::kable(data.frame('Число попаданий' = number_of_hits,
                        'Число квадратов' = freq_sim * 576,
                        'Число квадратов реальные данные' = number_of_squares,
                        'Наблюдаемая частота' = freq_sim,
                        'Теоретическая вероятность' = freq_pois),
             align = 'l', digits = 3)
```

Итак, результаты симуляции похожи на реальные данные (хотя полного совпадения не произошло, но этого и не следовало ожидать). В то же время наблюдаемые частоты хорошо согласуются с вероятностями, посчитанными на основе оценки параметра Пуассоновского распределения.

## Задание.

Ваша задача - определить, похожи ли представленные выше реальные данные на выборку из распределения Пуассона. Для этого оцените параметр распределения $\lambda$ (любым удобным способом) и сравните теоретические вероятности с наблюдаемыми, нанеся их на один график.

Вероятности можно посчитать с помощью `ppois()`. Возможно, хотя бы в одном номере не придется смотреть документацию `r ji('sweat')`

# Задача 4. Неравенство Йенсена и несмещенные оценки.

Продолжим работу с распределением Пуассона. Пусть у нас есть выборка из него, 
и мы хотели бы оценить $P(X=0)$. Сравним две стратегии:

- вероятность можно оценить как относительную частоту события $\{X=0\}$ среди всех реализаций случайной величины.

- можно оценить параметр $\lambda$, а с помощью него - вероятность как $e^{-\lambda}$

В первом случае, очевидно, такая оценка будет несмещенной (по той же самой причине, по которой частота выпадения единицы - несмещенная оценка параметра распределения Бернулли).

А что же во втором случае? Проведем симуляцию и посмотрим, как будет вести себя оценка. Не будем забывать, что оценка - это случайная величина, и поэтому мы можем симулировать ее реализации.

```{r}
lambd <- 3.14
realizations <- sapply(1:1e4, function(x) {exp( -mean(rpois(n = 10, lambda = lambd)))})
```

Функция `sapply()` в данном случае - лишь удобное сокращение, которое позволяет не пользоваться синтаксисом цикла.

Построим гистограмму из реализаций оценки и нанесем на нее истинное значение вероятности $e^{-3.14}=0.0433...$ и среднее значение полученной выборки при помощи `geom_vline()`:

```{r}
ggplot() + theme_classic() +
  geom_histogram(mapping = aes(x = realizations, y = ..density..),
                 color = 'black', fill = 'palegreen3', bins = 18, alpha = 0.8) +
  #вертикальные линии
  geom_vline(xintercept = exp(-3.14), 
             linetype = 'dashed', size = 1.1, color = 'blue') + 
  
  geom_vline(xintercept = mean(realizations), 
             linetype = 'dashed', size = 1.1, color = 'red')
```

Получается, что в среднем наша оценка завышала истинную вероятность. Это иллюстрирует вероятностная версия известного **неравенства Йенсена**: $$\phi(\mathbb{M}(X)) \leq \mathbb{M}(\phi(X))$$
для *выпуклой* функции $\phi(x)$. 

В нашем случае выпуклая функция - это $\phi(x)=e^{-x}$, $\mathbb{M}(X)=\lambda$, и слева в неравенстве стоит выпуклое преобразвание математического ожидания - $e^{-\mathbb{M}(X)}$.

Мы же пытаемся оценить его помощью $e^{-\overline{X}}$, хотя это (согласно закону больших чисел и свойствам сходимости случайных величин) - несмещенная оценка для правой части, которая в нашем случае строго больше (из-за строгой выпуклости $e^{-x}$).

Однако следует отметить, что у данной стратегии есть и свои плюсы. Рассмотрим выборку из распределения Пуассона с параметром $\lambda = 3.14$:

```{r}
pois <- c(2, 2, 2, 4, 5, 2, 6, 3, 5, 1)
```

Несмещенная оценка для $P(X=0)$ в этом случае будет равна нулю! Дело в том, что реальная вероятность $e^{-3.14}=0.0433...$ для такого значения параметра не превосходит $5\%$, и в десяти испытаниях событие $\{X=0\}$ не произошло ни разу. Смещенная же оценка равна:

```{r}
exp(-mean(pois))
```

и это гораздо ближе к истине. Данный пример должен напомнить, что несмещенность означает отсутствие *систематического* отклонения оценки от истинного значения. Из-за случайности для отдельно взятой выборки смещенная оценка может быть точнее.

## Задание.

Выберите какие-нибудь значения $\mu$ и $\sigma$ и *несмещенно* оцените стандартное отклонение для нормальной выборки при помощи оценки $$\overline{\sigma}=c_nS_n$$

где $S_n$ - корень из несмещенной оценки дисперсии (по выборке его считает функция `sd()`), а $$c_n=\sqrt{\frac{n-1}{2}}\frac{\Gamma(\frac{n-1}{2})}{\Gamma(\frac{n}{2})}$$

Гамма функцию $\Gamma(x)=\int_0^{+\infty}t^{x-1}e^{-t}dt$ можно посчитать с помощью `gamma()`.

$10000$ раз сгенерируйте нормальную выборку размера $5$ (чтобы смещение было еще довольно заметно) и на ее основе посчитайте несмещенную оценку. Сделать это можно циклом или с помощью `sapply()`.

Затем постройте аналогичную гистограмму и вертикальные линии - с настоящим стандартным отклонением и со средним из выборки оценок.